# Testing

Based on upstreams documentation https://github.com/thtanaka/kubernetes/blob/master/docs/devel/testing.md we use three levels of testing: unit, integration and e2e.

Running `make test` executes all the test suites.

We use ginkgo for testing. Every package needs a `suite_test.go` for setup. It can be generated by running `ginkgo bootstrap` in the sub folder. Rename the generated file afterwards, to stay consistent.
There is also `ginkgo generate` to create skeleton test files.

## Unit

While unit testing we:

* test classes in isolation
* pass all dependencies to the constructor, so we can inject fakes for testing
* use `counterfeiter` to generate and update fakes
* don't test private methods, tests are in a separate `_test` package
* try not to nest ginkgo contexts too deep and keep tests DRY by extracting useful helpers
* assert incoming messages produce the expected state
* assert outgoing commands happened, like a file gets written
* assert all handled error cases are triggered
* can ignore outgoing queries, which only change internal state

## Integration

Integration tests formulate expectations on the interactions of several components.
They require access to a Kubernetes, preferably `minikube`.

Integration tests start our operator directly, bypassing the command line.

The `environment` package provides helpers to start the operator, get the kubeconfig as well as defining and creating test objects.

Integration tests use a special logger, which does not log to stdout and whose messages can be accessed as a an array by calling `env.Logger.AllMessages()`.

## End-to-End

The e2e tests are meant to test acceptance scenarios. They are written from an end user perspective. They also require a running Kubernetes, but build our operator CLI themselves.

Currently we only have e2e tests for the command line options.


