// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	sync "sync"

	meta "k8s.io/apimachinery/pkg/api/meta"
	runtime "k8s.io/apimachinery/pkg/runtime"
	rest "k8s.io/client-go/rest"
	record "k8s.io/client-go/tools/record"
	cache "sigs.k8s.io/controller-runtime/pkg/cache"
	client "sigs.k8s.io/controller-runtime/pkg/client"
	manager "sigs.k8s.io/controller-runtime/pkg/manager"
	types "sigs.k8s.io/controller-runtime/pkg/webhook/admission/types"
)

type FakeManager struct {
	AddStub        func(manager.Runnable) error
	addMutex       sync.RWMutex
	addArgsForCall []struct {
		arg1 manager.Runnable
	}
	addReturns struct {
		result1 error
	}
	addReturnsOnCall map[int]struct {
		result1 error
	}
	GetAdmissionDecoderStub        func() types.Decoder
	getAdmissionDecoderMutex       sync.RWMutex
	getAdmissionDecoderArgsForCall []struct {
	}
	getAdmissionDecoderReturns struct {
		result1 types.Decoder
	}
	getAdmissionDecoderReturnsOnCall map[int]struct {
		result1 types.Decoder
	}
	GetCacheStub        func() cache.Cache
	getCacheMutex       sync.RWMutex
	getCacheArgsForCall []struct {
	}
	getCacheReturns struct {
		result1 cache.Cache
	}
	getCacheReturnsOnCall map[int]struct {
		result1 cache.Cache
	}
	GetClientStub        func() client.Client
	getClientMutex       sync.RWMutex
	getClientArgsForCall []struct {
	}
	getClientReturns struct {
		result1 client.Client
	}
	getClientReturnsOnCall map[int]struct {
		result1 client.Client
	}
	GetConfigStub        func() *rest.Config
	getConfigMutex       sync.RWMutex
	getConfigArgsForCall []struct {
	}
	getConfigReturns struct {
		result1 *rest.Config
	}
	getConfigReturnsOnCall map[int]struct {
		result1 *rest.Config
	}
	GetFieldIndexerStub        func() client.FieldIndexer
	getFieldIndexerMutex       sync.RWMutex
	getFieldIndexerArgsForCall []struct {
	}
	getFieldIndexerReturns struct {
		result1 client.FieldIndexer
	}
	getFieldIndexerReturnsOnCall map[int]struct {
		result1 client.FieldIndexer
	}
	GetRESTMapperStub        func() meta.RESTMapper
	getRESTMapperMutex       sync.RWMutex
	getRESTMapperArgsForCall []struct {
	}
	getRESTMapperReturns struct {
		result1 meta.RESTMapper
	}
	getRESTMapperReturnsOnCall map[int]struct {
		result1 meta.RESTMapper
	}
	GetRecorderStub        func(string) record.EventRecorder
	getRecorderMutex       sync.RWMutex
	getRecorderArgsForCall []struct {
		arg1 string
	}
	getRecorderReturns struct {
		result1 record.EventRecorder
	}
	getRecorderReturnsOnCall map[int]struct {
		result1 record.EventRecorder
	}
	GetSchemeStub        func() *runtime.Scheme
	getSchemeMutex       sync.RWMutex
	getSchemeArgsForCall []struct {
	}
	getSchemeReturns struct {
		result1 *runtime.Scheme
	}
	getSchemeReturnsOnCall map[int]struct {
		result1 *runtime.Scheme
	}
	SetFieldsStub        func(interface{}) error
	setFieldsMutex       sync.RWMutex
	setFieldsArgsForCall []struct {
		arg1 interface{}
	}
	setFieldsReturns struct {
		result1 error
	}
	setFieldsReturnsOnCall map[int]struct {
		result1 error
	}
	StartStub        func(<-chan struct{}) error
	startMutex       sync.RWMutex
	startArgsForCall []struct {
		arg1 <-chan struct{}
	}
	startReturns struct {
		result1 error
	}
	startReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeManager) Add(arg1 manager.Runnable) error {
	fake.addMutex.Lock()
	ret, specificReturn := fake.addReturnsOnCall[len(fake.addArgsForCall)]
	fake.addArgsForCall = append(fake.addArgsForCall, struct {
		arg1 manager.Runnable
	}{arg1})
	fake.recordInvocation("Add", []interface{}{arg1})
	fake.addMutex.Unlock()
	if fake.AddStub != nil {
		return fake.AddStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.addReturns
	return fakeReturns.result1
}

func (fake *FakeManager) AddCallCount() int {
	fake.addMutex.RLock()
	defer fake.addMutex.RUnlock()
	return len(fake.addArgsForCall)
}

func (fake *FakeManager) AddCalls(stub func(manager.Runnable) error) {
	fake.addMutex.Lock()
	defer fake.addMutex.Unlock()
	fake.AddStub = stub
}

func (fake *FakeManager) AddArgsForCall(i int) manager.Runnable {
	fake.addMutex.RLock()
	defer fake.addMutex.RUnlock()
	argsForCall := fake.addArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeManager) AddReturns(result1 error) {
	fake.addMutex.Lock()
	defer fake.addMutex.Unlock()
	fake.AddStub = nil
	fake.addReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) AddReturnsOnCall(i int, result1 error) {
	fake.addMutex.Lock()
	defer fake.addMutex.Unlock()
	fake.AddStub = nil
	if fake.addReturnsOnCall == nil {
		fake.addReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) GetAdmissionDecoder() types.Decoder {
	fake.getAdmissionDecoderMutex.Lock()
	ret, specificReturn := fake.getAdmissionDecoderReturnsOnCall[len(fake.getAdmissionDecoderArgsForCall)]
	fake.getAdmissionDecoderArgsForCall = append(fake.getAdmissionDecoderArgsForCall, struct {
	}{})
	fake.recordInvocation("GetAdmissionDecoder", []interface{}{})
	fake.getAdmissionDecoderMutex.Unlock()
	if fake.GetAdmissionDecoderStub != nil {
		return fake.GetAdmissionDecoderStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getAdmissionDecoderReturns
	return fakeReturns.result1
}

func (fake *FakeManager) GetAdmissionDecoderCallCount() int {
	fake.getAdmissionDecoderMutex.RLock()
	defer fake.getAdmissionDecoderMutex.RUnlock()
	return len(fake.getAdmissionDecoderArgsForCall)
}

func (fake *FakeManager) GetAdmissionDecoderCalls(stub func() types.Decoder) {
	fake.getAdmissionDecoderMutex.Lock()
	defer fake.getAdmissionDecoderMutex.Unlock()
	fake.GetAdmissionDecoderStub = stub
}

func (fake *FakeManager) GetAdmissionDecoderReturns(result1 types.Decoder) {
	fake.getAdmissionDecoderMutex.Lock()
	defer fake.getAdmissionDecoderMutex.Unlock()
	fake.GetAdmissionDecoderStub = nil
	fake.getAdmissionDecoderReturns = struct {
		result1 types.Decoder
	}{result1}
}

func (fake *FakeManager) GetAdmissionDecoderReturnsOnCall(i int, result1 types.Decoder) {
	fake.getAdmissionDecoderMutex.Lock()
	defer fake.getAdmissionDecoderMutex.Unlock()
	fake.GetAdmissionDecoderStub = nil
	if fake.getAdmissionDecoderReturnsOnCall == nil {
		fake.getAdmissionDecoderReturnsOnCall = make(map[int]struct {
			result1 types.Decoder
		})
	}
	fake.getAdmissionDecoderReturnsOnCall[i] = struct {
		result1 types.Decoder
	}{result1}
}

func (fake *FakeManager) GetCache() cache.Cache {
	fake.getCacheMutex.Lock()
	ret, specificReturn := fake.getCacheReturnsOnCall[len(fake.getCacheArgsForCall)]
	fake.getCacheArgsForCall = append(fake.getCacheArgsForCall, struct {
	}{})
	fake.recordInvocation("GetCache", []interface{}{})
	fake.getCacheMutex.Unlock()
	if fake.GetCacheStub != nil {
		return fake.GetCacheStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getCacheReturns
	return fakeReturns.result1
}

func (fake *FakeManager) GetCacheCallCount() int {
	fake.getCacheMutex.RLock()
	defer fake.getCacheMutex.RUnlock()
	return len(fake.getCacheArgsForCall)
}

func (fake *FakeManager) GetCacheCalls(stub func() cache.Cache) {
	fake.getCacheMutex.Lock()
	defer fake.getCacheMutex.Unlock()
	fake.GetCacheStub = stub
}

func (fake *FakeManager) GetCacheReturns(result1 cache.Cache) {
	fake.getCacheMutex.Lock()
	defer fake.getCacheMutex.Unlock()
	fake.GetCacheStub = nil
	fake.getCacheReturns = struct {
		result1 cache.Cache
	}{result1}
}

func (fake *FakeManager) GetCacheReturnsOnCall(i int, result1 cache.Cache) {
	fake.getCacheMutex.Lock()
	defer fake.getCacheMutex.Unlock()
	fake.GetCacheStub = nil
	if fake.getCacheReturnsOnCall == nil {
		fake.getCacheReturnsOnCall = make(map[int]struct {
			result1 cache.Cache
		})
	}
	fake.getCacheReturnsOnCall[i] = struct {
		result1 cache.Cache
	}{result1}
}

func (fake *FakeManager) GetClient() client.Client {
	fake.getClientMutex.Lock()
	ret, specificReturn := fake.getClientReturnsOnCall[len(fake.getClientArgsForCall)]
	fake.getClientArgsForCall = append(fake.getClientArgsForCall, struct {
	}{})
	fake.recordInvocation("GetClient", []interface{}{})
	fake.getClientMutex.Unlock()
	if fake.GetClientStub != nil {
		return fake.GetClientStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getClientReturns
	return fakeReturns.result1
}

func (fake *FakeManager) GetClientCallCount() int {
	fake.getClientMutex.RLock()
	defer fake.getClientMutex.RUnlock()
	return len(fake.getClientArgsForCall)
}

func (fake *FakeManager) GetClientCalls(stub func() client.Client) {
	fake.getClientMutex.Lock()
	defer fake.getClientMutex.Unlock()
	fake.GetClientStub = stub
}

func (fake *FakeManager) GetClientReturns(result1 client.Client) {
	fake.getClientMutex.Lock()
	defer fake.getClientMutex.Unlock()
	fake.GetClientStub = nil
	fake.getClientReturns = struct {
		result1 client.Client
	}{result1}
}

func (fake *FakeManager) GetClientReturnsOnCall(i int, result1 client.Client) {
	fake.getClientMutex.Lock()
	defer fake.getClientMutex.Unlock()
	fake.GetClientStub = nil
	if fake.getClientReturnsOnCall == nil {
		fake.getClientReturnsOnCall = make(map[int]struct {
			result1 client.Client
		})
	}
	fake.getClientReturnsOnCall[i] = struct {
		result1 client.Client
	}{result1}
}

func (fake *FakeManager) GetConfig() *rest.Config {
	fake.getConfigMutex.Lock()
	ret, specificReturn := fake.getConfigReturnsOnCall[len(fake.getConfigArgsForCall)]
	fake.getConfigArgsForCall = append(fake.getConfigArgsForCall, struct {
	}{})
	fake.recordInvocation("GetConfig", []interface{}{})
	fake.getConfigMutex.Unlock()
	if fake.GetConfigStub != nil {
		return fake.GetConfigStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getConfigReturns
	return fakeReturns.result1
}

func (fake *FakeManager) GetConfigCallCount() int {
	fake.getConfigMutex.RLock()
	defer fake.getConfigMutex.RUnlock()
	return len(fake.getConfigArgsForCall)
}

func (fake *FakeManager) GetConfigCalls(stub func() *rest.Config) {
	fake.getConfigMutex.Lock()
	defer fake.getConfigMutex.Unlock()
	fake.GetConfigStub = stub
}

func (fake *FakeManager) GetConfigReturns(result1 *rest.Config) {
	fake.getConfigMutex.Lock()
	defer fake.getConfigMutex.Unlock()
	fake.GetConfigStub = nil
	fake.getConfigReturns = struct {
		result1 *rest.Config
	}{result1}
}

func (fake *FakeManager) GetConfigReturnsOnCall(i int, result1 *rest.Config) {
	fake.getConfigMutex.Lock()
	defer fake.getConfigMutex.Unlock()
	fake.GetConfigStub = nil
	if fake.getConfigReturnsOnCall == nil {
		fake.getConfigReturnsOnCall = make(map[int]struct {
			result1 *rest.Config
		})
	}
	fake.getConfigReturnsOnCall[i] = struct {
		result1 *rest.Config
	}{result1}
}

func (fake *FakeManager) GetFieldIndexer() client.FieldIndexer {
	fake.getFieldIndexerMutex.Lock()
	ret, specificReturn := fake.getFieldIndexerReturnsOnCall[len(fake.getFieldIndexerArgsForCall)]
	fake.getFieldIndexerArgsForCall = append(fake.getFieldIndexerArgsForCall, struct {
	}{})
	fake.recordInvocation("GetFieldIndexer", []interface{}{})
	fake.getFieldIndexerMutex.Unlock()
	if fake.GetFieldIndexerStub != nil {
		return fake.GetFieldIndexerStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getFieldIndexerReturns
	return fakeReturns.result1
}

func (fake *FakeManager) GetFieldIndexerCallCount() int {
	fake.getFieldIndexerMutex.RLock()
	defer fake.getFieldIndexerMutex.RUnlock()
	return len(fake.getFieldIndexerArgsForCall)
}

func (fake *FakeManager) GetFieldIndexerCalls(stub func() client.FieldIndexer) {
	fake.getFieldIndexerMutex.Lock()
	defer fake.getFieldIndexerMutex.Unlock()
	fake.GetFieldIndexerStub = stub
}

func (fake *FakeManager) GetFieldIndexerReturns(result1 client.FieldIndexer) {
	fake.getFieldIndexerMutex.Lock()
	defer fake.getFieldIndexerMutex.Unlock()
	fake.GetFieldIndexerStub = nil
	fake.getFieldIndexerReturns = struct {
		result1 client.FieldIndexer
	}{result1}
}

func (fake *FakeManager) GetFieldIndexerReturnsOnCall(i int, result1 client.FieldIndexer) {
	fake.getFieldIndexerMutex.Lock()
	defer fake.getFieldIndexerMutex.Unlock()
	fake.GetFieldIndexerStub = nil
	if fake.getFieldIndexerReturnsOnCall == nil {
		fake.getFieldIndexerReturnsOnCall = make(map[int]struct {
			result1 client.FieldIndexer
		})
	}
	fake.getFieldIndexerReturnsOnCall[i] = struct {
		result1 client.FieldIndexer
	}{result1}
}

func (fake *FakeManager) GetRESTMapper() meta.RESTMapper {
	fake.getRESTMapperMutex.Lock()
	ret, specificReturn := fake.getRESTMapperReturnsOnCall[len(fake.getRESTMapperArgsForCall)]
	fake.getRESTMapperArgsForCall = append(fake.getRESTMapperArgsForCall, struct {
	}{})
	fake.recordInvocation("GetRESTMapper", []interface{}{})
	fake.getRESTMapperMutex.Unlock()
	if fake.GetRESTMapperStub != nil {
		return fake.GetRESTMapperStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getRESTMapperReturns
	return fakeReturns.result1
}

func (fake *FakeManager) GetRESTMapperCallCount() int {
	fake.getRESTMapperMutex.RLock()
	defer fake.getRESTMapperMutex.RUnlock()
	return len(fake.getRESTMapperArgsForCall)
}

func (fake *FakeManager) GetRESTMapperCalls(stub func() meta.RESTMapper) {
	fake.getRESTMapperMutex.Lock()
	defer fake.getRESTMapperMutex.Unlock()
	fake.GetRESTMapperStub = stub
}

func (fake *FakeManager) GetRESTMapperReturns(result1 meta.RESTMapper) {
	fake.getRESTMapperMutex.Lock()
	defer fake.getRESTMapperMutex.Unlock()
	fake.GetRESTMapperStub = nil
	fake.getRESTMapperReturns = struct {
		result1 meta.RESTMapper
	}{result1}
}

func (fake *FakeManager) GetRESTMapperReturnsOnCall(i int, result1 meta.RESTMapper) {
	fake.getRESTMapperMutex.Lock()
	defer fake.getRESTMapperMutex.Unlock()
	fake.GetRESTMapperStub = nil
	if fake.getRESTMapperReturnsOnCall == nil {
		fake.getRESTMapperReturnsOnCall = make(map[int]struct {
			result1 meta.RESTMapper
		})
	}
	fake.getRESTMapperReturnsOnCall[i] = struct {
		result1 meta.RESTMapper
	}{result1}
}

func (fake *FakeManager) GetRecorder(arg1 string) record.EventRecorder {
	fake.getRecorderMutex.Lock()
	ret, specificReturn := fake.getRecorderReturnsOnCall[len(fake.getRecorderArgsForCall)]
	fake.getRecorderArgsForCall = append(fake.getRecorderArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetRecorder", []interface{}{arg1})
	fake.getRecorderMutex.Unlock()
	if fake.GetRecorderStub != nil {
		return fake.GetRecorderStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getRecorderReturns
	return fakeReturns.result1
}

func (fake *FakeManager) GetRecorderCallCount() int {
	fake.getRecorderMutex.RLock()
	defer fake.getRecorderMutex.RUnlock()
	return len(fake.getRecorderArgsForCall)
}

func (fake *FakeManager) GetRecorderCalls(stub func(string) record.EventRecorder) {
	fake.getRecorderMutex.Lock()
	defer fake.getRecorderMutex.Unlock()
	fake.GetRecorderStub = stub
}

func (fake *FakeManager) GetRecorderArgsForCall(i int) string {
	fake.getRecorderMutex.RLock()
	defer fake.getRecorderMutex.RUnlock()
	argsForCall := fake.getRecorderArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeManager) GetRecorderReturns(result1 record.EventRecorder) {
	fake.getRecorderMutex.Lock()
	defer fake.getRecorderMutex.Unlock()
	fake.GetRecorderStub = nil
	fake.getRecorderReturns = struct {
		result1 record.EventRecorder
	}{result1}
}

func (fake *FakeManager) GetRecorderReturnsOnCall(i int, result1 record.EventRecorder) {
	fake.getRecorderMutex.Lock()
	defer fake.getRecorderMutex.Unlock()
	fake.GetRecorderStub = nil
	if fake.getRecorderReturnsOnCall == nil {
		fake.getRecorderReturnsOnCall = make(map[int]struct {
			result1 record.EventRecorder
		})
	}
	fake.getRecorderReturnsOnCall[i] = struct {
		result1 record.EventRecorder
	}{result1}
}

func (fake *FakeManager) GetScheme() *runtime.Scheme {
	fake.getSchemeMutex.Lock()
	ret, specificReturn := fake.getSchemeReturnsOnCall[len(fake.getSchemeArgsForCall)]
	fake.getSchemeArgsForCall = append(fake.getSchemeArgsForCall, struct {
	}{})
	fake.recordInvocation("GetScheme", []interface{}{})
	fake.getSchemeMutex.Unlock()
	if fake.GetSchemeStub != nil {
		return fake.GetSchemeStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getSchemeReturns
	return fakeReturns.result1
}

func (fake *FakeManager) GetSchemeCallCount() int {
	fake.getSchemeMutex.RLock()
	defer fake.getSchemeMutex.RUnlock()
	return len(fake.getSchemeArgsForCall)
}

func (fake *FakeManager) GetSchemeCalls(stub func() *runtime.Scheme) {
	fake.getSchemeMutex.Lock()
	defer fake.getSchemeMutex.Unlock()
	fake.GetSchemeStub = stub
}

func (fake *FakeManager) GetSchemeReturns(result1 *runtime.Scheme) {
	fake.getSchemeMutex.Lock()
	defer fake.getSchemeMutex.Unlock()
	fake.GetSchemeStub = nil
	fake.getSchemeReturns = struct {
		result1 *runtime.Scheme
	}{result1}
}

func (fake *FakeManager) GetSchemeReturnsOnCall(i int, result1 *runtime.Scheme) {
	fake.getSchemeMutex.Lock()
	defer fake.getSchemeMutex.Unlock()
	fake.GetSchemeStub = nil
	if fake.getSchemeReturnsOnCall == nil {
		fake.getSchemeReturnsOnCall = make(map[int]struct {
			result1 *runtime.Scheme
		})
	}
	fake.getSchemeReturnsOnCall[i] = struct {
		result1 *runtime.Scheme
	}{result1}
}

func (fake *FakeManager) SetFields(arg1 interface{}) error {
	fake.setFieldsMutex.Lock()
	ret, specificReturn := fake.setFieldsReturnsOnCall[len(fake.setFieldsArgsForCall)]
	fake.setFieldsArgsForCall = append(fake.setFieldsArgsForCall, struct {
		arg1 interface{}
	}{arg1})
	fake.recordInvocation("SetFields", []interface{}{arg1})
	fake.setFieldsMutex.Unlock()
	if fake.SetFieldsStub != nil {
		return fake.SetFieldsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.setFieldsReturns
	return fakeReturns.result1
}

func (fake *FakeManager) SetFieldsCallCount() int {
	fake.setFieldsMutex.RLock()
	defer fake.setFieldsMutex.RUnlock()
	return len(fake.setFieldsArgsForCall)
}

func (fake *FakeManager) SetFieldsCalls(stub func(interface{}) error) {
	fake.setFieldsMutex.Lock()
	defer fake.setFieldsMutex.Unlock()
	fake.SetFieldsStub = stub
}

func (fake *FakeManager) SetFieldsArgsForCall(i int) interface{} {
	fake.setFieldsMutex.RLock()
	defer fake.setFieldsMutex.RUnlock()
	argsForCall := fake.setFieldsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeManager) SetFieldsReturns(result1 error) {
	fake.setFieldsMutex.Lock()
	defer fake.setFieldsMutex.Unlock()
	fake.SetFieldsStub = nil
	fake.setFieldsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) SetFieldsReturnsOnCall(i int, result1 error) {
	fake.setFieldsMutex.Lock()
	defer fake.setFieldsMutex.Unlock()
	fake.SetFieldsStub = nil
	if fake.setFieldsReturnsOnCall == nil {
		fake.setFieldsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setFieldsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) Start(arg1 <-chan struct{}) error {
	fake.startMutex.Lock()
	ret, specificReturn := fake.startReturnsOnCall[len(fake.startArgsForCall)]
	fake.startArgsForCall = append(fake.startArgsForCall, struct {
		arg1 <-chan struct{}
	}{arg1})
	fake.recordInvocation("Start", []interface{}{arg1})
	fake.startMutex.Unlock()
	if fake.StartStub != nil {
		return fake.StartStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.startReturns
	return fakeReturns.result1
}

func (fake *FakeManager) StartCallCount() int {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return len(fake.startArgsForCall)
}

func (fake *FakeManager) StartCalls(stub func(<-chan struct{}) error) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = stub
}

func (fake *FakeManager) StartArgsForCall(i int) <-chan struct{} {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	argsForCall := fake.startArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeManager) StartReturns(result1 error) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = nil
	fake.startReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) StartReturnsOnCall(i int, result1 error) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = nil
	if fake.startReturnsOnCall == nil {
		fake.startReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addMutex.RLock()
	defer fake.addMutex.RUnlock()
	fake.getAdmissionDecoderMutex.RLock()
	defer fake.getAdmissionDecoderMutex.RUnlock()
	fake.getCacheMutex.RLock()
	defer fake.getCacheMutex.RUnlock()
	fake.getClientMutex.RLock()
	defer fake.getClientMutex.RUnlock()
	fake.getConfigMutex.RLock()
	defer fake.getConfigMutex.RUnlock()
	fake.getFieldIndexerMutex.RLock()
	defer fake.getFieldIndexerMutex.RUnlock()
	fake.getRESTMapperMutex.RLock()
	defer fake.getRESTMapperMutex.RUnlock()
	fake.getRecorderMutex.RLock()
	defer fake.getRecorderMutex.RUnlock()
	fake.getSchemeMutex.RLock()
	defer fake.getSchemeMutex.RUnlock()
	fake.setFieldsMutex.RLock()
	defer fake.setFieldsMutex.RUnlock()
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ manager.Manager = new(FakeManager)
